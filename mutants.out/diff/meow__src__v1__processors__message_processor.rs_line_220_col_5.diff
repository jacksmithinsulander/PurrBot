--- meow/src/v1/processors/message_processor.rs
+++ replace process_message -> Result<(), Box<dyn Error +Send +Sync>> with Ok(())
@@ -212,570 +212,17 @@
 }
 
 pub async fn process_message(
     bot: Bot,
     msg: Message,
     me: Me,
     config_store: std::sync::Arc<crate::v1::services::user_config_store::UserConfigStore>,
 ) -> Result<(), Box<dyn Error + Send + Sync>> {
-    if let Some(text) = msg.text() {
-        log::info!(
-            "Processing message: '{}' from chat_id={}",
-            text,
-            msg.chat.id
-        );
-
-        // Handle /logout command directly first
-        if text.trim().to_lowercase() == "/logout" {
-            log::info!(
-                "Handling /logout command directly for user {}",
-                msg.chat.id.0
-            );
-            
-            // Check if user is actually logged in first
-            let is_logged_in = {
-                let handlers = PASSWORD_HANDLERS.lock().await;
-                handlers.get(&msg.chat.id.0).and_then(|h| h.as_ref()).is_some()
-            };
-
-            if !is_logged_in {
-                log::info!("User {} tried to logout but is not logged in", msg.chat.id.0);
-                // Send error message
-                let message = bot
-                    .send_message(msg.chat.id, "❌ You are not logged in!")
-                    .reply_markup(logged_out_operations())
-                    .await?;
-                
-                // Store message IDs even in test mode
-                let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                return Ok(());
-            }
-            
-            // Clear state first
-            {
-                let mut states = log_in_state::USER_STATES.lock().await;
-                states.insert(msg.chat.id.0, log_in_state::AwaitingState::None);
-                log::info!("Reset state to None for user {}", msg.chat.id.0);
-            }
-
-            // Clear any existing password handler
-            {
-                let mut handlers = PASSWORD_HANDLERS.lock().await;
-                handlers.remove(&msg.chat.id.0);
-                log::info!("Cleared password handler for user {}", msg.chat.id.0);
-            }
-            // Set logged-out commands
-            if let Err(e) = bot
-                .set_my_commands(CommandLoggedOut::bot_commands())
-                .scope(BotCommandScope::Chat {
-                    chat_id: msg.chat.id.into(),
-                })
-                .await
-            {
-                log::warn!(
-                    "Failed to set logged-out commands for user {}: {}",
-                    msg.chat.id.0,
-                    e
-                );
-            } else {
-                log::info!("Set logged-out commands for user {}", msg.chat.id.0);
-            }
-            // Send logout confirmation message
-            let message = bot
-                .send_message(msg.chat.id, "👋 You have been logged out successfully!")
-                .reply_markup(logged_out_operations())
-                .await?;
-            log::info!(
-                "Logout confirmation message sent successfully to user {}",
-                msg.chat.id.0
-            );
-            // Store message IDs even in test mode
-            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-            return Ok(());
-        }
-
-        // Only delete messages if not in test mode
-        if std::env::var("TEST_MODE").is_err() {
-            log::debug!("Not in test mode, deleting previous messages");
-            delete_all_messages(msg.chat.id, &bot).await?;
-        } else {
-            log::debug!("In test mode, skipping message deletion");
-        }
-
-        // Track the user message for deletion next time (only if not in test mode)
-        if std::env::var("TEST_MODE").is_err() {
-            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-            chat_message_ids.insert(msg.chat.id, vec![msg.id]);
-        }
-
-        let user_id = msg.chat.id.0;
-        let user_state = {
-            let states = log_in_state::USER_STATES.lock().await;
-            states
-                .get(&user_id)
-                .copied()
-                .unwrap_or(log_in_state::AwaitingState::None)
-        };
-        log::info!("User {} state: {:?}", user_id, user_state);
-
-        // Always check for commands first, regardless of state
-        let is_logged_in = {
-            let handlers = PASSWORD_HANDLERS.lock().await;
-            handlers.get(&user_id).and_then(|h| h.as_ref()).is_some()
-        };
-        log::info!("User {} is_logged_in: {}", user_id, is_logged_in);
-
-        // Try to parse as CommandLoggedOut first for /start and /logout commands
-        log::debug!("Attempting to parse as CommandLoggedOut: {}", text);
-        match CommandLoggedOut::parse(text, me.username()) {
-            Ok(cmd) => {
-                log::info!("Successfully parsed as CommandLoggedOut: {:?}", cmd);
-                match cmd {
-                    CommandLoggedOut::Start => {
-                        log::info!("Handling /start command for user {}", user_id);
-                        // Reset state to None to ensure clean state
-                        {
-                            let mut states = log_in_state::USER_STATES.lock().await;
-                            states.insert(user_id, log_in_state::AwaitingState::None);
-                            log::info!("Reset state to None for user {}", user_id);
-                        }
-                        // Clear any existing password handler
-                        {
-                            let mut handlers = PASSWORD_HANDLERS.lock().await;
-                            handlers.remove(&user_id);
-                            log::info!("Cleared password handler for user {}", user_id);
-                        }
-                        // Set logged-out commands
-                        if let Err(e) = bot
-                            .set_my_commands(CommandLoggedOut::bot_commands())
-                            .scope(BotCommandScope::Chat {
-                                chat_id: msg.chat.id.into(),
-                            })
-                            .await
-                        {
-                            log::warn!(
-                                "Failed to set logged-out commands for user {}: {}",
-                                user_id,
-                                e
-                            );
-                        } else {
-                            log::info!("Set logged-out commands for user {}", user_id);
-                        }
-                        let keyboard = logged_out_operations();
-                        log::debug!("Sending welcome message to user {}", user_id);
-                        let message = bot
-                            .send_message(msg.chat.id, "💻 gm anon, whatchu wanna do? 🐈")
-                            .reply_markup(keyboard)
-                            .await?;
-                        log::info!("Welcome message sent successfully to user {}", user_id);
-                        if std::env::var("TEST_MODE").is_err() {
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        }
-                        return Ok(());
-                    }
-                    CommandLoggedOut::LogOut => {
-                        log::info!("Handling /logout command for user {}", user_id);
-                        // Clear state first
-                        {
-                            let mut states = log_in_state::USER_STATES.lock().await;
-                            states.insert(user_id, log_in_state::AwaitingState::None);
-                            log::info!("Reset state to None for user {}", user_id);
-                        }
-                        // Clear any existing password handler
-                        {
-                            let mut handlers = PASSWORD_HANDLERS.lock().await;
-                            handlers.remove(&user_id);
-                            log::info!("Cleared password handler for user {}", user_id);
-                        }
-                        // Set logged-out commands
-                        if let Err(e) = bot
-                            .set_my_commands(CommandLoggedOut::bot_commands())
-                            .scope(BotCommandScope::Chat {
-                                chat_id: msg.chat.id.into(),
-                            })
-                            .await
-                        {
-                            log::warn!(
-                                "Failed to set logged-out commands for user {}: {}",
-                                user_id,
-                                e
-                            );
-                        } else {
-                            log::info!("Set logged-out commands for user {}", user_id);
-                        }
-                        // Send logout confirmation message
-                        let message = bot
-                            .send_message(msg.chat.id, "👋 You have been logged out successfully!")
-                            .reply_markup(logged_out_operations())
-                            .await?;
-                        log::info!(
-                            "Logout confirmation message sent successfully to user {}",
-                            user_id
-                        );
-                        if std::env::var("TEST_MODE").is_err() {
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        }
-                        return Ok(());
-                    }
-                    _ => {
-                        log::debug!("Unhandled CommandLoggedOut variant: {:?}", cmd);
-                    }
-                }
-            }
-            Err(e) => {
-                log::warn!(
-                    "Failed to parse as CommandLoggedOut: '{}', error: {}",
-                    text,
-                    e
-                );
-                // Fallback: reply to user for unknown command
-                let message = bot
-                    .send_message(msg.chat.id, format!("❌ Unrecognized command: {}", text))
-                    .reply_markup(logged_out_operations())
-                    .await?;
-                if std::env::var("TEST_MODE").is_err() {
-                    let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                    chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                }
-                return Ok(());
-            }
-        }
-
-        // Try logged-in commands if logged in
-        if is_logged_in {
-            log::debug!(
-                "User is logged in, attempting to parse as CommandLoggedIn: {}",
-                text
-            );
-            if let Ok(cmd) = CommandLoggedIn::parse(text, me.username()) {
-                log::info!("Successfully parsed as CommandLoggedIn: {:?}", cmd);
-                match cmd {
-                    CommandLoggedIn::LogOut => {
-                        log::info!("Handling logged-in /logout command for user {}", user_id);
-                        logout(msg.chat.id, &bot).await?;
-                        log::info!("Logout completed for user {}", user_id);
-                        return Ok(());
-                    }
-                    CommandLoggedIn::PrintKeys => {
-                        print_keys(msg.chat.id, &bot).await?;
-                        return Ok(());
-                    }
-                    CommandLoggedIn::Start => {
-                        let message = bot
-                            .send_message(msg.chat.id, "😺 Welcome back! Here are your keys:")
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        print_keys(msg.chat.id, &bot).await?;
-                        return Ok(());
-                    }
-                    CommandLoggedIn::Help => {
-                        let message = bot
-                            .send_message(msg.chat.id, CommandLoggedIn::descriptions().to_string())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                    CommandLoggedIn::List => {
-                        log::info!("Handling /list command for user {}", user_id);
-                        // Verify login state
-                        let is_still_logged_in = {
-                            let handlers = PASSWORD_HANDLERS.lock().await;
-                            handlers.get(&user_id).and_then(|h| h.as_ref()).is_some()
-                        };
-
-                        if !is_still_logged_in {
-                            log::warn!("User {} tried to use /list but is not logged in", user_id);
-                            let message = bot
-                                .send_message(msg.chat.id, "❌ Please log in first!")
-                                .reply_markup(logged_out_operations())
-                                .await?;
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                            return Ok(());
-                        }
-
-                        let message = bot
-                            .send_message(msg.chat.id, "📋 Listing your items...")
-                            .reply_markup(logged_in_operations())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        log::info!("Successfully sent list response to user {}", user_id);
-                        return Ok(());
-                    }
-                    CommandLoggedIn::Trade => {
-                        let message = bot
-                            .send_message(msg.chat.id, "🔄 Trading interface coming soon...")
-                            .reply_markup(logged_in_operations())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                    CommandLoggedIn::Create => {
-                        let message = bot
-                            .send_message(msg.chat.id, "✨ Create interface coming soon...")
-                            .reply_markup(logged_in_operations())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                }
-            } else {
-                log::debug!("Failed to parse as CommandLoggedIn: {}", text);
-            }
-        }
-
-        // Now try the rest of the logged-out commands if not already handled
-        log::debug!("Trying to parse as CommandLoggedOut: {}", text);
-        if let Ok(cmd) = CommandLoggedOut::parse(text, me.username()) {
-            log::info!("User {} parsed logged-out command: {:?}", user_id, cmd);
-            match cmd {
-                CommandLoggedOut::Help => {
-                    let message = bot
-                        .send_message(msg.chat.id, CommandLoggedOut::descriptions().to_string())
-                        .await?;
-                    let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                    chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                    return Ok(());
-                }
-                // Start and LogOut are already handled above
-                CommandLoggedOut::SignUp { password } => {
-                    // Check if already logged in
-                    if is_logged_in {
-                        log::info!("User {} tried to signup but is already logged in", user_id);
-                        let message = bot
-                            .send_message(msg.chat.id, "❌ You are already logged in! Please logout first.")
-                            .reply_markup(logged_in_operations())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                    
-                    let handler = PasswordHandler::new(config_store.clone())?;
-                    let user_id = msg.chat.id.0.to_string();
-                    match handler.sign_up(&user_id, &password).await {
-                        Ok(config) => {
-                            let message = bot.send_message(msg.chat.id, "Account created successfully! 🎉\nNow enter your password again to log in.").await?;
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                            log::info!(
-                                "User {} created account with config: {}",
-                                msg.chat.id.0,
-                                config
-                            );
-                            {
-                                let mut states = log_in_state::USER_STATES.lock().await;
-                                states.insert(
-                                    msg.chat.id.0,
-                                    log_in_state::AwaitingState::AwaitingLoginPassword,
-                                );
-                            }
-                            // Store the handler
-                            {
-                                let mut handler_lock = PASSWORD_HANDLERS.lock().await;
-                                handler_lock.insert(msg.chat.id.0, Some(handler));
-                            }
-                        }
-                        Err(e) => {
-                            let message = bot
-                                .send_message(
-                                    msg.chat.id,
-                                    format!("Failed to create account: {}", e),
-                                )
-                                .await?;
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                            log::error!(
-                                "Failed to create account for user {}: {}",
-                                msg.chat.id.0,
-                                e
-                            );
-                        }
-                    }
-                    return Ok(());
-                }
-                CommandLoggedOut::LogIn { password } => {
-                    // Check if already logged in
-                    if is_logged_in {
-                        log::info!("User {} tried to login but is already logged in", user_id);
-                        let message = bot
-                            .send_message(msg.chat.id, "❌ You are already logged in!")
-                            .reply_markup(logged_in_operations())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                    
-                    let handler = PasswordHandler::new(config_store.clone())?;
-                    let user_id = msg.chat.id.0.to_string();
-                    match handler.login(&user_id, &password).await {
-                        Ok(true) => {
-                            // Set logged-in commands first
-                            bot.set_my_commands(CommandLoggedIn::bot_commands())
-                                .scope(BotCommandScope::Chat {
-                                    chat_id: msg.chat.id.into(),
-                                })
-                                .await?;
-
-                            // Store the handler before sending messages
-                            {
-                                let mut handler_lock = PASSWORD_HANDLERS.lock().await;
-                                handler_lock.insert(msg.chat.id.0, Some(handler));
-                            }
-
-                            // Update user state
-                            {
-                                let mut states = log_in_state::USER_STATES.lock().await;
-                                states.insert(msg.chat.id.0, log_in_state::AwaitingState::None);
-                            }
-
-                            // Send success message
-                            let message = bot
-                                .send_message(msg.chat.id, "Logged in successfully! 🎉")
-                                .reply_markup(logged_in_operations())
-                                .await?;
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-
-                            log::info!("User {} logged in successfully", msg.chat.id.0);
-
-                            // Print keys after successful login
-                            print_keys(msg.chat.id, &bot).await?;
-                            return Ok(());
-                        }
-                        Ok(false) => {
-                            let message = bot
-                                .send_message(msg.chat.id, "Invalid password! ❌")
-                                .await?;
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                            log::warn!("User {} failed to log in", msg.chat.id.0);
-                        }
-                        Err(e) => {
-                            let message = bot
-                                .send_message(msg.chat.id, format!("Failed to log in: {}", e))
-                                .await?;
-                            let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                            chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                            log::error!("Failed to log in user {}: {}", msg.chat.id.0, e);
-                        }
-                    }
-                    return Ok(());
-                }
-                // Start and LogOut are already handled above
-                _ => {}
-            }
-        }
-
-        // If not a command, handle password input based on state
-        match user_state {
-            log_in_state::AwaitingState::AwaitingLoginPassword => {
-                let handler = PasswordHandler::new(config_store.clone())?;
-                let user_id = msg.chat.id.0.to_string();
-                match handler.login(&user_id, text).await {
-                    Ok(true) => {
-                        bot.set_my_commands(CommandLoggedIn::bot_commands())
-                            .scope(BotCommandScope::Chat {
-                                chat_id: msg.chat.id.into(),
-                            })
-                            .await?;
-                        let message = bot
-                            .send_message(msg.chat.id, "Logged in successfully! 🎉")
-                            .reply_markup(logged_in_operations())
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        log::info!("User {} logged in successfully", msg.chat.id.0);
-                        // Store the handler
-                        {
-                            let mut handler_lock = PASSWORD_HANDLERS.lock().await;
-                            handler_lock.insert(msg.chat.id.0, Some(handler));
-                        }
-                        print_keys(msg.chat.id, &bot).await?;
-                        {
-                            let mut states = log_in_state::USER_STATES.lock().await;
-                            states.insert(msg.chat.id.0, log_in_state::AwaitingState::None);
-                        }
-                        return Ok(());
-                    }
-                    Ok(false) => {
-                        let message = bot
-                            .send_message(msg.chat.id, "Invalid password! ❌")
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                    Err(e) => {
-                        let message = bot
-                            .send_message(msg.chat.id, format!("Login failed: {}", e))
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        return Ok(());
-                    }
-                }
-            }
-            log_in_state::AwaitingState::AwaitingSignUpPassword => {
-                let handler = PasswordHandler::new(config_store.clone())?;
-                let user_id = msg.chat.id.0.to_string();
-                match handler.sign_up(&user_id, text).await {
-                    Ok(config) => {
-                        let message = bot.send_message(msg.chat.id, "Account created successfully! 🎉\nNow enter your password again to log in.").await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        log::info!(
-                            "User {} created account with config: {}",
-                            msg.chat.id.0,
-                            config
-                        );
-                        {
-                            let mut states = log_in_state::USER_STATES.lock().await;
-                            states.insert(
-                                msg.chat.id.0,
-                                log_in_state::AwaitingState::AwaitingLoginPassword,
-                            );
-                        }
-                        // Store the handler
-                        {
-                            let mut handler_lock = PASSWORD_HANDLERS.lock().await;
-                            handler_lock.insert(msg.chat.id.0, Some(handler));
-                        }
-                    }
-                    Err(e) => {
-                        let message = bot
-                            .send_message(msg.chat.id, format!("Failed to create account: {}", e))
-                            .await?;
-                        let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                        chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-                        log::error!("Failed to create account for user {}: {}", msg.chat.id.0, e);
-                    }
-                }
-                return Ok(());
-            }
-            log_in_state::AwaitingState::None => {
-                let message = bot.send_message(msg.chat.id, "Command not found!").await?;
-                let mut chat_message_ids = CHAT_MESSAGE_IDS.lock().await;
-                chat_message_ids.insert(msg.chat.id, vec![msg.id, message.id]);
-            }
-        }
-    }
-
-    Ok(())
+    Ok(()) /* ~ changed by cargo-mutants ~ */
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
     
     // Test that public functions exist
     #[test]
